{"pages":[],"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2022/06/20/hello-world/"},{"title":"create2","text":"目的 透過 create2 可以算出未來會產生出合約的地址 因此可以先將此地址呈現給使用者，讓他們需要儲值時，可以把幣打進去該地址 參考文章第一篇、第二篇 原本的合約創建方式新合約的地址由創建合約交易的發送者賬戶地址及其 nonce 值計算得到： 合約地址 = hash (msg.sender, nonce ) 問題在於，你很難真正佔住地址 1new DeployWithCreate2{salt: bytes32(_salt)}(msg.sender); create2 地址計算方式文件解說參考 keccak256(0xff ++ deployersAddr ++ salt ++ keccak256(bytecode))[12:] 0xFF, is a single byte the address of the deployer, so the Smart Contracts address that sends the CREATE2 A random salt And the hashed bytecode that will be deployed on that particular address 計算 hash 先取得要部署合約的creation code，type(DeployWithCreate2).creationCode 如果部署的合約有參數，則在第二個參數傳入，並使用abi.encodeabi.encodePacked(bytecode, abi.encode(_owner))如果有多個參數，則將多個參數包含在 abi.encode 中1234function getBytesCode(address _owner, uint _uint) public pure returns (bytes memory) { bytes memory bytecode = type(DeployWithCreate2).creationCode; return abi.encodePacked(bytecode, abi.encode(_owner,_uint));} 計算地址 先計算出 hash 需要四樣，將這些透過 abi.encodePacked 起來，然後再透過 keccak256 加密， 如：keccak256(abi.encodePacked(bytes1(0xff), deployer, _salt, keccak256(bytecode))) bytes1(0xff) deployer salt keccak256(bytecode)這邊的 bytecode 就是type(contract)的creationCode 1bytecode = abi.encodePacked(type(pair).creationCode) 再將此 hash 轉 uint，再轉成 uint160，將此值換成 address address(uint160(uint256(hash))) 部署 new 合約，使用 salt，參數則是寫在()中new DeployWithCreate2{salt: bytes32(_salt)}(msg.sender) 完整合約12345678910111213141516171819202122232425262728293031323334353637383940// SPDX-License-Identifier: MITpragma solidity &gt;=0.8.0 &lt;0.9.0;import \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";contract DeployWithCreate2 { address public owner; constructor(address _address) { address hotWallet = _address; //將token賦予要使用幣的地址 ERC20 token = ERC20(0xcacE8f13C6C857c8a6a47B7aC0BA53b755237C74); token.transfer(hotWallet,token.balanceOf(address(this))); selfdestruct (payable(address (0))); }}contract Create2Factory { event Deploy(address _address); function deploy(uint256 _salt) public { DeployWithCreate2 _contract = new DeployWithCreate2{salt: bytes32(_salt)}(msg.sender); emit Deploy(address(_contract)); } function getAddress(bytes memory bytecode, uint256 _salt) public view returns (address) { bytes32 hash = keccak256(abi.encodePacked(bytes1(0xff), address(this), _salt, keccak256(bytecode))); return address(uint160(uint256(hash))); } function getBytesCode(address _owner) public pure returns (bytes memory) { bytes memory bytecode = type(DeployWithCreate2).creationCode; return abi.encodePacked(bytecode, abi.encode(_owner)); }}","link":"/2022/04/20/create2/"}],"tags":[],"categories":[]}