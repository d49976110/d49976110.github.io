{"pages":[],"posts":[{"title":"如何使用solidity中的create2","text":"目的 透過 create2 可以算出未來會產生出合約的地址 因此可以先將此地址呈現給使用者，讓他們需要儲值時，可以把幣打進去該地址 原本的合約創建方式新合約的地址由創建合約交易的發送者賬戶地址及其 nonce 值計算得到： 合約地址 = hash (msg.sender, nonce ) 問題在於，你很難真正佔住地址 1new DeployWithCreate2{salt: bytes32(_salt)}(msg.sender); create2 地址計算方式文件解說keccak256(0xff ++ deployersAddr ++ salt ++ keccak256(bytecode))[12:] 0xFF, is a single byte the address of the deployer, so the Smart Contracts address that sends the CREATE2 A random salt And the hashed bytecode that will be deployed on that particular address 計算 hash 先取得要部署合約的creation code，type(DeployWithCreate2).creationCode 如果部署的合約有參數，則在第二個參數傳入，並使用abi.encodeabi.encodePacked(bytecode, abi.encode(_owner))如果有多個參數，則將多個參數包含在 abi.encode 中 1234function getBytesCode(address _owner, uint _uint) public pure returns (bytes memory) { bytes memory bytecode = type(DeployWithCreate2).creationCode; return abi.encodePacked(bytecode, abi.encode(_owner,_uint));} 計算地址 先計算出 hash 需要四樣，將這些透過 abi.encodePacked 起來，然後再透過 keccak256 加密， 如：keccak256(abi.encodePacked(bytes1(0xff), deployer, _salt, keccak256(bytecode))) bytes1(0xff) deployer salt keccak256(bytecode)這邊的 bytecode 就是type(contract)的creationCode 1bytecode = abi.encodePacked(type(pair).creationCode) 再將此 hash 轉 uint，再轉成 uint160，將此值換成 address address(uint160(uint256(hash))) 部署 new 合約，使用 salt，參數則是寫在()中new DeployWithCreate2{salt: bytes32(_salt)}(msg.sender) 完整合約12345678910111213141516171819202122232425262728293031323334353637383940// SPDX-License-Identifier: MITpragma solidity &gt;=0.8.0 &lt;0.9.0;import \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";contract DeployWithCreate2 { address public owner; constructor(address _address) { address hotWallet = _address; //將token賦予要使用幣的地址 ERC20 token = ERC20(0xcacE8f13C6C857c8a6a47B7aC0BA53b755237C74); token.transfer(hotWallet,token.balanceOf(address(this))); selfdestruct (payable(address (0))); }}contract Create2Factory { event Deploy(address _address); function deploy(uint256 _salt) public { DeployWithCreate2 _contract = new DeployWithCreate2{salt: bytes32(_salt)}(msg.sender); emit Deploy(address(_contract)); } function getAddress(bytes memory bytecode, uint256 _salt) public view returns (address) { bytes32 hash = keccak256(abi.encodePacked(bytes1(0xff), address(this), _salt, keccak256(bytecode))); return address(uint160(uint256(hash))); } function getBytesCode(address _owner) public pure returns (bytes memory) { bytes memory bytecode = type(DeployWithCreate2).creationCode; return abi.encodePacked(bytecode, abi.encode(_owner)); }}","link":"/2022/03/20/create2/"},{"title":"Uniswap v2機制說明與程式碼解說","text":"整體架構 用户 =&gt; 周邊合約 =&gt; 核心合約 周邊合約主要是用戶跟核心合約之間的橋梁 運行邏輯： uniswap 分為 3 個核心合約，工廠合約、配對合約與 erc20 合約 核心合約部署時只需要部工廠合約 工廠合約部署時，建構子只需要設定一個手續費管理員 要在交易所中進行交易，操作順序為：創建交易對、添加流動性、交易 添加配對合約時需要提供兩個 token 的地址，工廠合約就可以透過 create2 方法，為此交易對部署一個配對合約 兩個 token 地址按大小排序後，透過 hash，則成為 create2 的 salt 配對合約的地址，是可以透過兩個 token 地址進行 create2 計算而得 用戶可以將兩個 token 存入到配對合約中，然後再配對合約中為用戶生成 LP token 此 LP token 即為流動性 用戶可以取出流動性，配對合約就會銷毀該流動性 token，並將兩種 token 同時返回給用戶 返還的數量將根據目前兩種 token 的儲備量重新計算，如果有手續費收益，用戶也將獲得收益 用戶可以透過一種 token 交換另一種 token，配對合約將扣除千分之 3 的手續費 在 uniswap 的合約中，還有周邊的路由合約，用來提供更好的操作體驗 路由合約擁有三個主要的操作方法：添加流動性、移除流動性、交換 雖然配對合約已經可以完成所有的交易，但是透過路由合約配合前端可以獲得更好的用戶體驗 核心合約uniswap 主要有三份合約 factory uniswapERC20 pair 後續為了加強使用性，加上了router Factory#創建 #排序 #uniswap create pairs 的時候就已經先做好 tokenA &amp; tokenB 的排序 12345678910111213141516function createPair(address tokenA, address tokenB) external returns (address pair) { require(tokenA != tokenB, 'UniswapV2: IDENTICAL_ADDRESSES'); (address token0, address token1) = tokenA &lt; tokenB ? (tokenA, tokenB) : (tokenB, tokenA); require(token0 != address(0), 'UniswapV2: ZERO_ADDRESS'); require(getPair[token0][token1] == address(0), 'UniswapV2: PAIR_EXISTS'); // single check is sufficient bytes memory bytecode = type(UniswapV2Pair).creationCode; bytes32 salt = keccak256(abi.encodePacked(token0, token1)); assembly { pair := create2(0, add(bytecode, 32), mload(bytecode), salt) } IUniswapV2Pair(pair).initialize(token0, token1); getPair[token0][token1] = pair; getPair[token1][token0] = pair; // populate mapping in the reverse direction allPairs.push(pair); emit PairCreated(token0, token1, pair, allPairs.length);} UniswapERC20permit 簽章 簽張的內容：[PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline] 確認簽章的內容為本人後，就會授權該合約使用 user 的 token 1234567891011121314151617181920212223242526272829303132function permit( address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s ) external { require(deadline &gt;= block.timestamp, \"UniswapV2: EXPIRED\"); bytes32 digest = keccak256( abi.encodePacked( \"\\x19\\x01\", DOMAIN_SEPARATOR, keccak256( abi.encode( PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline ) ) ) ); address recoveredAddress = ecrecover(digest, v, r, s); require( recoveredAddress != address(0) &amp;&amp; recoveredAddress == owner, \"UniswapV2: INVALID_SIGNATURE\" ); _approve(owner, spender, value); constructor 如果是 solidity 8.0 之後，chainId := chainid，要改成chainId := block.chainid 12345678910111213141516171819pragma solidity =0.5.16;constructor() public { uint256 chainId; assembly { chainId := chainid } DOMAIN_SEPARATOR = keccak256( abi.encode( keccak256( \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\" ), keccak256(bytes(name)), keccak256(bytes(\"1\")), chainId, address(this) ) );} Pairs總共有三個主要的 function，在 mint 時 LP 的算法為 只有在交易時才會被收取千分之三的手續費，但是只有在改變流動性時才會透過_mintFee將手續費發到指定的feeTo地址 被 Factoryinitial時，token0 &amp; token1 就已經被寫入 swap swap 的方法中，有{}包起來的部分是因為，訪問堆棧時最多只能訪問 16 個插槽，當訪問的插槽數超過 16 個時在編譯時就會產生stack too deep errors price0Cumulative採用累積價格是因為要防止攻擊，所以採用時間權重的方式","link":"/2022/04/17/uniswapv2/"},{"title":"Solidity abi 使用說明","text":"abi 說明總共有分為以下四種： abi.encode(...) returns (bytes)：計算參數的 ABI 編碼。 abi.encodePacked(...) returns (bytes)：計算參數的打包編碼 abi. encodeWithSelector(bytes4 selector, ...) returns (bytes)： 計算函數選擇器和參數的 ABI 編碼 abi.encodeWithSelector(bytes4(keccak256(signature), ...)等於abi.encodeWithSignature(string signature, ...) 底下的這三種方式所得到的結果都是一樣的0x60fe47b1 123abi.encodeWithSelector(bytes4(keccak256(\"set(uint256)\")));abi.encodeWithSignature(\"set(uint256)\");bytes4(keccak256(\"set(uint256)\")); 如果需要加參數 12abi.encodeWithSelector(bytes4(keccak256(\"set(uint256)\")),10);abi.encodeWithSignature(\"set(uint256)\",10); 摘要 abi.encodeWithSignature的返回值為 bytes，以下面為例，返回值會有 36 個字節，前 4 個會是 function 的，後面 32 個則是參數的abi.encodeWithSignature(\"store(uint256)\",10) = 此四個 bytes 是 function selector0x6057361d 此 32 個 bytes 是參數的000000000000000000000000000000000000000000000000000000000000000a abi.encodeWithSignature實作原理就是透過keccak256(bytes(function_name))，執行完後取前四個 bytes，若沒參數則補 0 call function可以使用底層的 call 來呼叫其他合約的 function&lt;address&gt;.call(bytes memory)，通常的使用時機為製作 multisig wallet 時會使用到，尤其中的一個多錢包擁有者發起一個提案，裡面的 data 放上需要執行的bytes，當此提案通過後，即可透過 call 執行 使用底層的 call，可以直接使用address來透過abi.encodeWithSignature(”set(uint256)”,10)呼叫其他合約的 function 12345678//a.contractfunction myFunction(uint _x,address _addr)publicreturns(uint,uint) { // do something return (a, b);}//multisig wallet(bool success,bytes memory result)= addr.call(abi.encodeWithSignature(\"myFunction(uint,address)\", 10, msg.sender)); 摘要 call function 內需要的是 bytes，所以需要透過abi.encodeWithSignature轉換 abi.encodeWithSignature內的方法參數型別如果是 uint，需要寫完整的型別uint256 call 執行完成後回傳的參數是bool與bytes&lt;address&gt;.call(bytes memory) returns (bool, bytes memory) call &amp; delegate call 的差異 call其他的合約，會在 call 的address合約中改動 data delegatecall，執行完成會後改動自己合約中的 data 但是目前發現如果針對同一份合約調用 call 與 delegate call，當執行過 delegatecall，似乎就無法再執行 call，這部分如果有人知道為什麼，再請跟我說一下，謝謝 123456789101112131415161718192021222324contract callee { uint public a ; uint public b ; function test() public returns (uint){ a += 10; b = a ; return b; }}contract caller { uint public a; address callee ; constructor(address _address){ callee = _address; } function call()external { callee.call(abi.encodeWithSignature(\"test()\")); } function delegatecall()external{ callee.delegatecall(abi.encodeWithSignature(\"test()\")); }}","link":"/2022/04/21/abi-%E8%AA%AA%E6%98%8E/"}],"tags":[],"categories":[]}