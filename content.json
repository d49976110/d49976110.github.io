{"pages":[{"title":"About Me","text":"Hi I’m Brian, focusing on the development of solidity.Has implemented ERC20, ERC721, multi-currency swap contracts, staking contracts, multisig wallet, and studied Uniswap V2 contract , cross-chain mechanism and wrote cross-chain contracts. If you want to contact me, please contact : bc.medium.1221@gmail.com","link":"/about/index.html"},{"title":"categories","text":"","link":"/categories/index.html"}],"posts":[{"title":"如何使用solidity中的create2","text":"目的 透過 create2 可以算出未來會產生出合約的地址 因此可以先將此地址呈現給使用者，讓他們需要儲值時，可以把幣打進去該地址 原本的合約創建方式新合約的地址由創建合約交易的發送者賬戶地址及其 nonce 值計算得到： 合約地址 = hash (msg.sender, nonce ) 問題在於，你很難真正佔住地址 1new DeployWithCreate2{salt: bytes32(_salt)}(msg.sender); create2 地址計算方式文件解說keccak256(0xff ++ deployersAddr ++ salt ++ keccak256(bytecode))[12:] 0xFF, is a single byte the address of the deployer, so the Smart Contracts address that sends the CREATE2 A random salt And the hashed bytecode that will be deployed on that particular address 計算 hash 先取得要部署合約的creation code，type(DeployWithCreate2).creationCode 如果部署的合約有參數，則在第二個參數傳入，並使用abi.encodeabi.encodePacked(bytecode, abi.encode(_owner))如果有多個參數，則將多個參數包含在 abi.encode 中 1234function getBytesCode(address _owner, uint _uint) public pure returns (bytes memory) { bytes memory bytecode = type(DeployWithCreate2).creationCode; return abi.encodePacked(bytecode, abi.encode(_owner,_uint));} 計算地址 先計算出 hash 需要四樣，將這些透過 abi.encodePacked 起來，然後再透過 keccak256 加密， 如：keccak256(abi.encodePacked(bytes1(0xff), deployer, _salt, keccak256(bytecode))) bytes1(0xff) deployer salt keccak256(bytecode)這邊的 bytecode 就是type(contract)的creationCode 1bytecode = abi.encodePacked(type(pair).creationCode) 再將此 hash 轉 uint，再轉成 uint160，將此值換成 address address(uint160(uint256(hash))) 部署 new 合約，使用 salt，參數則是寫在()中new DeployWithCreate2{salt: bytes32(_salt)}(msg.sender) 完整合約12345678910111213141516171819202122232425262728293031323334353637383940// SPDX-License-Identifier: MITpragma solidity &gt;=0.8.0 &lt;0.9.0;import \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";contract DeployWithCreate2 { address public owner; constructor(address _address) { address hotWallet = _address; //將token賦予要使用幣的地址 ERC20 token = ERC20(0xcacE8f13C6C857c8a6a47B7aC0BA53b755237C74); token.transfer(hotWallet,token.balanceOf(address(this))); selfdestruct (payable(address (0))); }}contract Create2Factory { event Deploy(address _address); function deploy(uint256 _salt) public { DeployWithCreate2 _contract = new DeployWithCreate2{salt: bytes32(_salt)}(msg.sender); emit Deploy(address(_contract)); } function getAddress(bytes memory bytecode, uint256 _salt) public view returns (address) { bytes32 hash = keccak256(abi.encodePacked(bytes1(0xff), address(this), _salt, keccak256(bytecode))); return address(uint160(uint256(hash))); } function getBytesCode(address _owner) public pure returns (bytes memory) { bytes memory bytecode = type(DeployWithCreate2).creationCode; return abi.encodePacked(bytecode, abi.encode(_owner)); }} 歡迎轉載與分享，但請註明出處，感謝～版權聲明：本文為 bc-blog.live 文章，遵循 CC 4.0 BY-SA 版權協議，轉載請附上原文出處鏈接和本聲明。","link":"/2022/03/20/create2/"},{"title":"Uniswap v2機制說明與程式碼解說","text":"整體架構 合約分為兩個部分，分別為核心合約與周邊合約 user透過核心合約中的factory合約來創建pair合約，並透過router合約來添加或是移除流動性 因此，周邊合約主要是方便使用者始與核心合約交互使用。可以看作是使用者跟核心合約之間的橋梁 運行邏輯 Uniswap v2 共有 3 個核心合約，分別為factory(工廠合約)、pair(配對合約)與Erc20合約 配對合約繼承 ERC20 合約，只是這個合約與一般的 ERC20 多了permit的方法，因此透過 pair 合約創建出來的 token 為 ERC20 token 核心合約部署時只需要部署工廠合約，他會創建出配對合約 工廠合約部署時，constructor需要設定一個feeToSetter(手續費管理員) 要在交易所中進行交易，操作順序為： 透過工廠合約創建配對合約 透過 router 合約，針對此配對合約添加流動性 透過 router 合約執行 swap token 添加配對合約時需要提供兩個 token 的地址，工廠合約就可以透過create2方法，為此交易對部署一個配對合約 兩個 token 地址按大小排序後，透過 hash，則成為 create2 的 salt 透過type(UniswapV2Pair).creationCode取得配對合約的 byte code 使用者可以將兩個 token 存入到配對合約中，然後透過配對合約中的mint為使用者生成 token 此 token 就是所謂的LP token即為流動性，同時也是 ERC20 token 使用者可以透過配對合約中的burn取出流動性，配對合約就會銷毀該 LP token，並將兩種 token 按照池子內的比例，同時返回給用戶 返還的數量將根據目前兩種 token 的reserve(儲備量)重新計算，如果有手續費收益，用戶也在此動作執行時將獲得收益 使用者可以透過配對合約中的swap，將 A token 交換另一種 B token，配對合約將扣除千分之 3 的手續費 執行該swap時，需要先將 A token 發送到配對合約(加上手續費)，才能順利兌換成 B token 配對合約已經可以完成所有的交易，但是為了讓使用者增加更好的體驗，Uniswap v2 的合約中周邊的router合約，透過該合約配合前端可以使整體體驗更流暢。 router 合約擁有三個主要的操作方法：添加流動性、移除流動性、交換 核心合約Uniswap v2 主要有三份合約 factory:創建配對合約 pair: 繼承底下 ERC20 合約 UniswapERC20:與一般 ERC20 多 permit 方法 FactoryFactory的主要功能是創建 Pair 合約，透過createPair創建，需傳入 tokenA &amp; tokenB 12345678910111213141516171819function createPair(address tokenA, address tokenB) external returns (address pair) { require(tokenA != tokenB, 'UniswapV2: IDENTICAL_ADDRESSES'); //排序 (address token0, address token1) = tokenA &lt; tokenB ? (tokenA, tokenB) : (tokenB, tokenA); require(token0 != address(0), 'UniswapV2: ZERO_ADDRESS'); require(getPair[token0][token1] == address(0), 'UniswapV2: PAIR_EXISTS'); //create2 bytes memory bytecode = type(UniswapV2Pair).creationCode; bytes32 salt = keccak256(abi.encodePacked(token0, token1)); assembly { pair := create2(0, add(bytecode, 32), mload(bytecode), salt) } //初始化 IUniswapV2Pair(pair).initialize(token0, token1); getPair[token0][token1] = pair; getPair[token1][token0] = pair; allPairs.push(pair); emit PairCreated(token0, token1, pair, allPairs.length);} 在第二行的部分會先做好 tokenA &amp; tokenB 的排序。因為 address 型別的底層為 uint160，所以可以透過比大小排序。 透過 create2 創建 pair 合約 創建完 pair 合約後，執行initialize對合約做初始化 這邊可能會有疑問： 為什麼使用 create2，而不是直接使用 new contract 加上 constructor ?⇒ 我目前的認知是因為要讓前端可以計算出合約地址，如果有人知道更多詳細內容的，也再請跟我說，感謝 UniswapERC20這邊的 UniswapERC20 與一般的 ERC20，主要差別在於多了permit這個 function，用途是為了維持交易的原子性。 由於 router 合約在removeLiquidity時會調用 pair 合約中的transferFrom，因此使用者會需要先 approve 給 router 合約，才能使 router 合約調用此 pair 合約的 LP token。 但是如果有了 permit 的方法，則不需要事先 approve。可以讓 router 直接執行 permit 後，接著執行 transferFrom，這兩個方法都是在同一筆交易中完成。 好處是可以讓使用者少做一次動作，節省 gas fee 並維持交易的原子性。 permit 原理12345678910111213function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external { require(deadline &gt;= block.timestamp, 'UniswapV2: EXPIRED'); bytes32 digest = keccak256( abi.encodePacked( '\\x19\\x01', DOMAIN_SEPARATOR, keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline)) ) ); address recoveredAddress = ecrecover(digest, v, r, s); require(recoveredAddress != address(0) &amp;&amp; recoveredAddress == owner, 'UniswapV2: INVALID_SIGNATURE'); _approve(owner, spender, value);} 先在前端請使用者簽一段訊息，內容如下： '\\x19\\x01' DOMAIN_SEPARATOR [PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline] 完成後，前端先解析此簽章，得出v、s、r，連同傳入 owner、spender、value、deadline，一併傳進permit。這邊的 owner、spender、value、deadline，也就是上面讓前端使用者簽名的訊息內容 將這些訊息透過 keccak256 加密後可得到 digest1abi.encodePacked('\\x19\\x01', DOMAIN_SEPARATOR, keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))); 將digest與v、s、r透過ecrecover，則可以得到一組地址，將此地址與 owner 比對，如果一樣，則執行_approve PairsPair 合約主要有三個重要的 function，分別是 mint、burn、swap mint主要是用來創造流動性，返回值為流動性的數值。 初始流動性算法為初次注入的token0 &amp; token1數量相乘，開根號 後續流動性算法，則是按照token0(或是token1)投入的數量與當前池子中的token0(或是token1)數量的比例，乘上當前所有的流動性。 123456789101112131415161718192021222324252627function mint(address to) external lock returns (uint liquidity) { (uint112 _reserve0, uint112 _reserve1,) = getReserves(); uint balance0 = IERC20(token0).balanceOf(address(this)); uint balance1 = IERC20(token1).balanceOf(address(this)); //token傳進來的量 uint amount0 = balance0.sub(_reserve0); uint amount1 = balance1.sub(_reserve1); bool feeOn = _mintFee(_reserve0, _reserve1); //LP的totalsupply uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee if (_totalSupply == 0) { // x*y開根號，首次鑄造攻擊 liquidity = Math.sqrt(amount0.mul(amount1)).sub(MINIMUM_LIQUIDITY); _mint(address(0), MINIMUM_LIQUIDITY); // permanently lock the first MINIMUM_LIQUIDITY tokens } else { // amount0/_reserve0 * totalSupply liquidity = Math.min(amount0.mul(_totalSupply) / _reserve0, amount1.mul(_totalSupply) / _reserve1); } require(liquidity &gt; 0, 'UniswapV2: INSUFFICIENT_LIQUIDITY_MINTED'); _mint(to, liquidity); //balance:目前合約擁有的餘額 reserve:尚未更新前的儲備量 _update(balance0, balance1, _reserve0, _reserve1); if (feeOn) kLast = uint(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date emit Mint(msg.sender, amount0, amount1);} 第一行，取得當前的儲備量_reserve0 &amp; _reserve1 取得當前合約的 token0 &amp; token1 餘額。為什麼會這樣寫，是因為要執行此 function 時，會需要先將要鑄造成流動性的 token0 &amp; token1 先傳進此合約。 當前此合約 token0 的 balance 減去當前儲備量的_reserve0，則是代表是為了要鑄造成流動性而剛傳入的 token0 數量 待完成… 歡迎轉載與分享，但請註明出處，感謝～版權聲明：本文為 bc-blog.live 文章，遵循 CC 4.0 BY-SA 版權協議，轉載請附上原文出處鏈接和本聲明。","link":"/2022/04/17/uniswapv2/"},{"title":"Solidity abi 使用說明","text":"abi 說明總共有分為以下四種： abi.encode(...) returns (bytes)：計算參數的 ABI 編碼。 abi.encodePacked(...) returns (bytes)：計算參數的打包編碼 abi. encodeWithSelector(bytes4 selector, ...) returns (bytes)： 計算函數選擇器和參數的 ABI 編碼 abi.encodeWithSelector(bytes4(keccak256(signature), ...)等於abi.encodeWithSignature(string signature, ...) 底下的這三種方式所得到的結果都是一樣的0x60fe47b1 123abi.encodeWithSelector(bytes4(keccak256(\"set(uint256)\")));abi.encodeWithSignature(\"set(uint256)\");bytes4(keccak256(\"set(uint256)\")); 如果需要加參數 12abi.encodeWithSelector(bytes4(keccak256(\"set(uint256)\")),10);abi.encodeWithSignature(\"set(uint256)\",10); 摘要 abi.encodeWithSignature的返回值為 bytes，以下面為例，返回值會有 36 個字節，前 4 個會是 function 的，後面 32 個則是參數的abi.encodeWithSignature(\"store(uint256)\",10) = 此四個 bytes 是 function selector0x6057361d 此 32 個 bytes 是參數的000000000000000000000000000000000000000000000000000000000000000a abi.encodeWithSignature實作原理就是透過keccak256(bytes(function_name))，執行完後取前四個 bytes，若沒參數則補 0 call function可以使用底層的 call 來呼叫其他合約的 function&lt;address&gt;.call(bytes memory)，通常的使用時機為製作 multisig wallet 時會使用到，尤其中的一個多錢包擁有者發起一個提案，裡面的 data 放上需要執行的bytes，當此提案通過後，即可透過 call 執行 使用底層的 call，可以直接使用address來透過abi.encodeWithSignature(”set(uint256)”,10)呼叫其他合約的 function 12345678//a.contractfunction myFunction(uint _x,address _addr)publicreturns(uint,uint) { // do something return (a, b);}//multisig wallet(bool success,bytes memory result)= addr.call(abi.encodeWithSignature(\"myFunction(uint,address)\", 10, msg.sender)); 摘要 call function 內需要的是 bytes，所以需要透過abi.encodeWithSignature轉換 abi.encodeWithSignature內的方法參數型別如果是 uint，需要寫完整的型別uint256 call 執行完成後回傳的參數是bool與bytes&lt;address&gt;.call(bytes memory) returns (bool, bytes memory) call &amp; delegate call 的差異 call其他的合約，會在 call 的address合約中改動 data delegatecall，執行完成會後改動自己合約中的 data 但是目前發現如果針對同一份合約調用 call 與 delegate call，當執行過 delegatecall，似乎就無法再執行 call，這部分如果有人知道為什麼，再請跟我說一下，謝謝 123456789101112131415161718192021222324contract callee { uint public a ; uint public b ; function test() public returns (uint){ a += 10; b = a ; return b; }}contract caller { uint public a; address callee ; constructor(address _address){ callee = _address; } function call()external { callee.call(abi.encodeWithSignature(\"test()\")); } function delegatecall()external{ callee.delegatecall(abi.encodeWithSignature(\"test()\")); }} 歡迎轉載與分享，但請註明出處，感謝～版權聲明：本文為 bc-blog.live 文章，遵循 CC 4.0 BY-SA 版權協議，轉載請附上原文出處鏈接和本聲明。","link":"/2022/04/21/abi-%E8%AA%AA%E6%98%8E/"},{"title":"ERC165，為什麼我們需要他?從interfaceId用法與解說講起","text":"ERC165，為什麼我們需要他由於發現 ERC165 的中文資料實在是太少了，就針對我目前的了解，簡單做個紀錄。 為什麼需要一般我們在寫合約時，會使用到繼承，但是往往不確定目前繼承的合約，是否真的有使用到 ERC20 或是 ERC721 等標準，當然可以一層一層的去看目前繼承的這個合約是否有使用其他 ERC 標準，但每次都這樣確實有點麻煩，因此有 ERC165 的出現。 但在理解 ERC165 之前，讓我們先來了解一下什麼是type(Interface).interfaceId type(Interface).interfaceId 主要會返回該介面的 XOR selector(function name)、參數(function parameter)，不管返回值。 返回值的型別為bytes4 補充：XOR 是兩個運算式上做邏輯互斥，用人話說就是代表兩兩相同時會互相抵銷，舉個例子： A XOR B XOR B ⇒ result = A A XOR A XOR B XOR B XOR C ⇒ result = C A B A XOR B 0 0 0 1 0 1 0 1 1 1 1 0 回歸到原本的 type(I).interfaceId： 如果該介面是空的，則IID_ITEST返回0x00000000 1234567// SPDX-License-Identifier: MITpragma solidity ^0.8.11;interface ITest {}contract Test is ITest { bytes4 public constant IID_ITEST = type(ITest).interfaceId;} 介面擁有相同的函式名稱，即使一個有返回值，另一個沒有，但IID_ITEST結果兩者會一樣 1234567891011121314151617181920212223// SPDX-License-Identifier: MITpragma solidity ^0.8.11;interface ITest { function getTest() external;}contract Test is ITest { bytes4 public constant IID_ITEST = type(ITest).interfaceId; function getTest() external override { }}===========// SPDX-License-Identifier: MITpragma solidity ^0.8.11;interface ITest { function getTest() external returns (uint);}contract Test is ITest { bytes4 public constant IID_ITEST = type(ITest).interfaceId; function getTest() external pure override returns (uint) { return 0; }} 介面擁有相同的函式名稱，參數名稱不一樣，IID_ITEST結果仍兩者會一樣 12345678910111213141516171819202122232425// SPDX-License-Identifier: MITpragma solidity ^0.8.11;interface ITest { function getTest(uint name) external returns (uint);}contract Test is ITest { bytes4 public constant IID_ITEST = type(ITest).interfaceId; function getTest(uint name) external pure override returns (uint) { return name; }}===========// SPDX-License-Identifier: MITpragma solidity ^0.8.11;interface ITest { function getTest(uint name2) external returns (uint);}contract Test is ITest { bytes4 public constant IID_ITEST = type(ITest).interfaceId; function getTest(uint name2) external pure override returns (uint) { return name2; }} 介面擁有相同的函式名稱，但是參數的型別不一樣，則IID_ITEST返回值就會不一樣 12345678910111213141516171819202122232425// SPDX-License-Identifier: MITpragma solidity ^0.8.11;interface ITest { function getTest(uint name) external returns (uint);}contract Test1 is ITest { bytes4 public constant IID_ITEST = type(ITest).interfaceId; function getTest(uint name) external pure override returns (uint) { return name; }}===========// SPDX-License-Identifier: MITpragma solidity ^0.8.11;interface ITest { function getTest(address name2) external returns (address);}contract Test2 is ITest { bytes4 public constant IID_ITEST = type(ITest).interfaceId; function getTest(address name2) external pure override returns (address) { return name2; }} 小結如果兩個介面的函式名稱與參數的型別都一樣，則會返回相同的值，因此如果兩個介面的type(Interface).interfaceId一樣，就可以確認他們所擁有的函式與函式中的型別都是一樣。 ERC165 原理學會了上面的type(interface).interfaceId接下來我們繼續看 ERC165 一般判斷兩個 method 是否相同，除了用眼睛看之外，也可以透過bytes4(keccak256(“function()”))，將函式轉換成bytes4來做比較。 bytes4(keccak256(“function()”)) 與function.seletor，結果是一樣 1234567891011121314151617181920212223242526272829303132// SPDX-License-Identifier: UNLICENCEDpragma solidity &gt;=0.8.0 &lt;0.9.0;interface Solidity101 { function hello() external pure; function world(int) external pure;}contract Selector { function calculateSelector() public pure returns (bytes4) { Solidity101 i; return i.hello.selector ^ i.world.selector; // Returns 0xc6be8b58 } function getInterface()public pure returns(bytes4){ return type(Solidity101).interfaceId; // Returns 0xc6be8b58 } function getHelloSelector() public pure returns (bytes4) { Solidity101 i; return i.hello.selector; // Returns 0x19ff1d21 } function getWorldSelector() public pure returns (bytes4) { Solidity101 i; return i.world.selector; // Returns 0xdf419679 }} 結論因此，透過上面的calculateSelector()或是getInterface()，就能夠透過將所有的 method1.seletor ^method2.seletor ^ method3.seletor…簡化成一個 bytes4 只要想要比較的兩個合約 byte4 是相等的，就可以確認兩者的有的函式是一樣的，因此可以確認對方有實現該介面中所有的方法，以上大概就是 ERC165 的邏輯。 歡迎轉載與分享，但請註明出處，感謝～版權聲明：本文為 bc-blog.live 文章，遵循 CC 4.0 BY-SA 版權協議，轉載請附上原文出處鏈接和本聲明。","link":"/2022/04/26/interfaceId/"},{"title":"如何撰寫出一個好的Git Commit","text":"Git Commit 基礎規範根據此篇文章的結論，大致上可以列出一下規範： 用一行空白行分隔標題與內容 限制標題最多只有 50 字元（主要也是因問 git log 最多呈現 50 字元） 標題開頭要大寫 標題不需要句點結尾，浪費空間 以祈使句撰寫標題，也就是說直接用原形動詞開頭，不需要考慮動詞型態 內文每行最多 72 字 用內文解釋 what 以及 why vs. how Git Commit 進階撰寫風格根據上面的規則，可以再進行更進階的處理，分別為以下幾點： 發開 feat: 新增/修改/調整功能。 fix: 修補漏洞。 test: 新增/修改/調整測試。 docs: 新增/修改/調整文件。 style: 新增/修改/調整格式 (不影響程式碼運行的變動)。 word: 頁面上的文字修改。 維護/優化 refactor: 重構 (既不是新增功能，也不是修補 bug 的程式碼變動)。 perf: 優化效能。 chore: 建構程序或輔助工具的變動。 其他 other:其他不屬於任何上面類的情境 以上為大致的分類，當然可以按照個人或是團隊的需求來增減，但是主要目的都是有一個規範，可以讓大家在閱讀 git log 時，可以更快速的找到自己所需要的 commit。 歡迎轉載與分享，但請註明出處，感謝～版權聲明：本文為 bc-blog.live 文章，遵循 CC 4.0 BY-SA 版權協議，轉載請附上原文出處鏈接和本聲明。","link":"/2021/07/20/git/"}],"tags":[{"name":"interfaceId","slug":"interfaceId","link":"/tags/interfaceId/"},{"name":"git","slug":"git","link":"/tags/git/"}],"categories":[]}